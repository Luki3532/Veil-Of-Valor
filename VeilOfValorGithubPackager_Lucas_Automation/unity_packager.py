#!/usr/bin/env python3
"""
Unity Project Packager
A standalone script to package Unity projects for sharing by removing unnecessary files.

Author: Auto-generated
Date: December 1, 2025
License: Free to use and modify

Usage:
    python unity_packager.py
    
Or with command line arguments:
    python unity_packager.py /path/to/unity/project
"""

import os
import sys
import shutil
import zipfile
import logging
import argparse
from pathlib import Path
from datetime import datetime
from typing import List, Optional, Tuple


# ============================================================================
# CONFIGURATION
# ============================================================================

# Folders to remove (these are auto-generated by Unity)
FOLDERS_TO_REMOVE = [
    "Library",
    "Temp",
    "Logs",
    "Obj",
    "obj",
    "Build",
    "Builds",
    ".vs",
    "UserSettings",
    "Recordings",  # Unity recorder cache
]

# File patterns to remove
FILE_PATTERNS_TO_REMOVE = [
    "*.csproj",
    "*.sln",
    ".DS_Store",  # macOS
    "Thumbs.db",  # Windows
]

# Required folders for a valid Unity project
REQUIRED_UNITY_FOLDERS = ["Assets", "ProjectSettings"]

# Optional but common Unity folders to keep
OPTIONAL_UNITY_FOLDERS = ["Packages"]

# Minimum free space required (in bytes) - 10 GB
MIN_FREE_SPACE = 10 * 1024 * 1024 * 1024


# ============================================================================
# LOGGING SETUP
# ============================================================================

def setup_logging(verbose: bool = False) -> logging.Logger:
    """Set up logging configuration with both file and console handlers."""
    log_level = logging.DEBUG if verbose else logging.INFO
    
    # Create logs directory if it doesn't exist
    log_dir = Path.cwd() / "unity_packager_logs"
    log_dir.mkdir(exist_ok=True)
    
    # Create log filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = log_dir / f"unity_packager_{timestamp}.log"
    
    # Configure logging
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file, encoding='utf-8'),
            logging.StreamHandler(sys.stdout)
        ]
    )
    
    logger = logging.getLogger(__name__)
    logger.info(f"Logging initialized. Log file: {log_file}")
    return logger


# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def get_directory_size(path: Path) -> int:
    """Calculate total size of a directory in bytes."""
    total_size = 0
    try:
        for entry in path.rglob('*'):
            if entry.is_file():
                try:
                    total_size += entry.stat().st_size
                except (PermissionError, OSError) as e:
                    logger.warning(f"Cannot get size of {entry}: {e}")
    except Exception as e:
        logger.error(f"Error calculating directory size for {path}: {e}")
    return total_size


def format_size(bytes_size: int) -> str:
    """Format bytes to human-readable size."""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if bytes_size < 1024.0:
            return f"{bytes_size:.2f} {unit}"
        bytes_size /= 1024.0
    return f"{bytes_size:.2f} PB"


def get_free_space(path: Path) -> int:
    """Get free space in bytes for the drive containing the path."""
    try:
        if sys.platform == 'win32':
            import ctypes
            free_bytes = ctypes.c_ulonglong(0)
            ctypes.windll.kernel32.GetDiskFreeSpaceExW(
                ctypes.c_wchar_p(str(path)), 
                None, 
                None, 
                ctypes.pointer(free_bytes)
            )
            return free_bytes.value
        else:
            stat = os.statvfs(path)
            return stat.f_bavail * stat.f_frsize
    except Exception as e:
        logger.warning(f"Could not determine free space: {e}")
        return MIN_FREE_SPACE  # Assume we have enough


def validate_unity_project(project_path: Path) -> Tuple[bool, str]:
    """
    Validate if the given path is a valid Unity project.
    
    Returns:
        Tuple of (is_valid, error_message)
    """
    if not project_path.exists():
        return False, f"Path does not exist: {project_path}"
    
    if not project_path.is_dir():
        return False, f"Path is not a directory: {project_path}"
    
    # Check for required folders
    missing_folders = []
    for folder in REQUIRED_UNITY_FOLDERS:
        folder_path = project_path / folder
        if not folder_path.exists() or not folder_path.is_dir():
            missing_folders.append(folder)
    
    if missing_folders:
        return False, f"Missing required Unity folders: {', '.join(missing_folders)}"
    
    logger.info(f"✓ Valid Unity project detected: {project_path.name}")
    return True, ""


def safe_remove_directory(dir_path: Path) -> bool:
    """Safely remove a directory with error handling."""
    if not dir_path.exists():
        logger.debug(f"Directory does not exist, skipping: {dir_path}")
        return True
    
    try:
        logger.info(f"Removing directory: {dir_path.name}")
        shutil.rmtree(dir_path, ignore_errors=False)
        logger.debug(f"✓ Successfully removed: {dir_path}")
        return True
    except PermissionError as e:
        logger.error(f"✗ Permission denied removing {dir_path}: {e}")
        return False
    except Exception as e:
        logger.error(f"✗ Error removing {dir_path}: {e}")
        return False


def safe_remove_file(file_path: Path) -> bool:
    """Safely remove a file with error handling."""
    if not file_path.exists():
        return True
    
    try:
        file_path.unlink()
        logger.debug(f"✓ Removed file: {file_path.name}")
        return True
    except PermissionError as e:
        logger.error(f"✗ Permission denied removing {file_path}: {e}")
        return False
    except Exception as e:
        logger.error(f"✗ Error removing {file_path}: {e}")
        return False


def copy_directory_with_exclusions(
    src: Path, 
    dst: Path, 
    exclude_folders: List[str],
    progress_callback=None
) -> bool:
    """
    Copy directory while excluding certain folders.
    
    Args:
        src: Source directory
        dst: Destination directory
        exclude_folders: List of folder names to exclude
        progress_callback: Optional callback function for progress updates
    
    Returns:
        True if successful, False otherwise
    """
    try:
        dst.mkdir(parents=True, exist_ok=True)
        
        total_items = sum(1 for _ in src.rglob('*'))
        processed_items = 0
        
        for item in src.rglob('*'):
            # Check if any parent directory should be excluded
            should_exclude = False
            for part in item.relative_to(src).parts:
                if part in exclude_folders:
                    should_exclude = True
                    break
            
            if should_exclude:
                continue
            
            # Calculate destination path
            relative_path = item.relative_to(src)
            dest_path = dst / relative_path
            
            try:
                if item.is_dir():
                    dest_path.mkdir(parents=True, exist_ok=True)
                else:
                    dest_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(item, dest_path)
                
                processed_items += 1
                if progress_callback and processed_items % 100 == 0:
                    progress = int((processed_items / total_items) * 100)
                    progress_callback(progress, f"Copying files... ({processed_items}/{total_items})")
                    
            except Exception as e:
                logger.warning(f"Could not copy {item}: {e}")
                continue
        
        logger.info(f"✓ Copied {processed_items} items from {src.name}")
        return True
        
    except Exception as e:
        logger.error(f"✗ Error copying directory: {e}")
        return False


def remove_unnecessary_folders(clean_path: Path, folders_to_remove: List[str]) -> int:
    """Remove unnecessary folders from the clean project."""
    removed_count = 0
    
    for folder_name in folders_to_remove:
        folder_path = clean_path / folder_name
        if safe_remove_directory(folder_path):
            removed_count += 1
    
    logger.info(f"✓ Removed {removed_count} unnecessary folders")
    return removed_count


def remove_unnecessary_files(clean_path: Path, file_patterns: List[str]) -> int:
    """Remove unnecessary files based on patterns."""
    removed_count = 0
    
    for pattern in file_patterns:
        try:
            for file_path in clean_path.glob(pattern):
                if file_path.is_file() and safe_remove_file(file_path):
                    removed_count += 1
        except Exception as e:
            logger.warning(f"Error processing pattern {pattern}: {e}")
    
    logger.info(f"✓ Removed {removed_count} unnecessary files")
    return removed_count


def create_zip_archive(source_dir: Path, zip_path: Path, progress_callback=None) -> bool:
    """
    Create a ZIP archive from a directory.
    
    Args:
        source_dir: Directory to compress
        zip_path: Output ZIP file path
        progress_callback: Optional callback for progress updates
    
    Returns:
        True if successful, False otherwise
    """
    try:
        # Remove existing zip if it exists
        if zip_path.exists():
            logger.info(f"Removing existing ZIP file: {zip_path}")
            zip_path.unlink()
        
        logger.info(f"Creating ZIP archive: {zip_path.name}")
        
        # Count total files
        all_files = list(source_dir.rglob('*'))
        total_files = len([f for f in all_files if f.is_file()])
        processed_files = 0
        
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for file_path in all_files:
                if file_path.is_file():
                    try:
                        arcname = file_path.relative_to(source_dir.parent)
                        zipf.write(file_path, arcname)
                        
                        processed_files += 1
                        if progress_callback and processed_files % 50 == 0:
                            progress = int((processed_files / total_files) * 100)
                            progress_callback(progress, f"Compressing... ({processed_files}/{total_files})")
                            
                    except Exception as e:
                        logger.warning(f"Could not add {file_path} to ZIP: {e}")
        
        logger.info(f"✓ Created ZIP archive with {processed_files} files")
        logger.info(f"✓ ZIP size: {format_size(zip_path.stat().st_size)}")
        return True
        
    except Exception as e:
        logger.error(f"✗ Error creating ZIP archive: {e}")
        return False


# ============================================================================
# MAIN PACKAGING FUNCTION
# ============================================================================

def package_unity_project(project_path: Path, output_dir: Optional[Path] = None) -> bool:
    """
    Main function to package a Unity project.
    
    Args:
        project_path: Path to the Unity project
        output_dir: Optional output directory (defaults to project parent)
    
    Returns:
        True if successful, False otherwise
    """
    logger.info("=" * 70)
    logger.info("UNITY PROJECT PACKAGER - STARTING")
    logger.info("=" * 70)
    
    # Step 1: Validate Unity project
    logger.info("\n[STEP 1/7] Validating Unity project...")
    is_valid, error_msg = validate_unity_project(project_path)
    if not is_valid:
        logger.error(f"✗ Validation failed: {error_msg}")
        return False
    
    # Step 2: Calculate original size
    logger.info("\n[STEP 2/7] Calculating project size...")
    original_size = get_directory_size(project_path)
    logger.info(f"Original project size: {format_size(original_size)}")
    
    # Step 3: Check free space
    logger.info("\n[STEP 3/7] Checking available disk space...")
    free_space = get_free_space(project_path)
    logger.info(f"Available disk space: {format_size(free_space)}")
    
    if free_space < MIN_FREE_SPACE:
        logger.error(f"✗ Insufficient disk space. Need at least {format_size(MIN_FREE_SPACE)}")
        response = input("Continue anyway? (yes/no): ").strip().lower()
        if response not in ['yes', 'y']:
            logger.info("Operation cancelled by user")
            return False
    
    # Step 4: Set up paths
    logger.info("\n[STEP 4/7] Setting up paths...")
    project_name = project_path.name
    parent_dir = output_dir or project_path.parent
    clean_path = parent_dir / f"{project_name}_CLEAN"
    zip_path = parent_dir / f"{project_name}_CLEAN.zip"
    
    logger.info(f"Clean directory: {clean_path}")
    logger.info(f"ZIP file: {zip_path}")
    
    # Remove existing clean directory if it exists
    if clean_path.exists():
        logger.warning(f"Clean directory already exists: {clean_path}")
        response = input("Remove and continue? (yes/no): ").strip().lower()
        if response not in ['yes', 'y']:
            logger.info("Operation cancelled by user")
            return False
        safe_remove_directory(clean_path)
    
    # Step 5: Copy project with exclusions
    logger.info("\n[STEP 5/7] Copying project files...")
    
    def progress_update(percent, message):
        print(f"\r{message} [{percent}%]", end='', flush=True)
    
    success = copy_directory_with_exclusions(
        project_path, 
        clean_path, 
        FOLDERS_TO_REMOVE,
        progress_update
    )
    print()  # New line after progress
    
    if not success:
        logger.error("✗ Failed to copy project files")
        return False
    
    # Step 6: Clean up unnecessary files
    logger.info("\n[STEP 6/7] Removing unnecessary files...")
    remove_unnecessary_folders(clean_path, FOLDERS_TO_REMOVE)
    remove_unnecessary_files(clean_path, FILE_PATTERNS_TO_REMOVE)
    
    # Calculate clean size
    clean_size = get_directory_size(clean_path)
    logger.info(f"Clean project size: {format_size(clean_size)}")
    
    size_reduction = original_size - clean_size
    reduction_percent = (size_reduction / original_size * 100) if original_size > 0 else 0
    logger.info(f"Size reduced by: {format_size(size_reduction)} ({reduction_percent:.1f}%)")
    
    # Step 7: Create ZIP archive
    logger.info("\n[STEP 7/7] Creating ZIP archive...")
    success = create_zip_archive(clean_path, zip_path, progress_update)
    print()  # New line after progress
    
    if not success:
        logger.error("✗ Failed to create ZIP archive")
        return False
    
    # Clean up temporary directory
    logger.info("\nCleaning up temporary files...")
    safe_remove_directory(clean_path)
    
    # Final summary
    logger.info("\n" + "=" * 70)
    logger.info("PACKAGING COMPLETED SUCCESSFULLY!")
    logger.info("=" * 70)
    logger.info(f"Original size:  {format_size(original_size)}")
    logger.info(f"Package size:   {format_size(zip_path.stat().st_size)}")
    logger.info(f"Reduction:      {format_size(size_reduction)} ({reduction_percent:.1f}%)")
    logger.info(f"Output file:    {zip_path}")
    logger.info("=" * 70)
    
    return True


# ============================================================================
# INTERACTIVE MODE
# ============================================================================

def interactive_mode():
    """Run the packager in interactive mode."""
    print("\n" + "=" * 70)
    print("UNITY PROJECT PACKAGER - Interactive Mode")
    print("=" * 70)
    
    while True:
        print("\nEnter the path to your Unity project folder:")
        print("(or 'quit' to exit)")
        
        user_input = input("> ").strip()
        
        if user_input.lower() in ['quit', 'exit', 'q']:
            print("Goodbye!")
            return
        
        if not user_input:
            print("Please enter a valid path.")
            continue
        
        project_path = Path(user_input).resolve()
        
        # Validate and package
        if package_unity_project(project_path):
            print("\n✓ SUCCESS! Your Unity project has been packaged.")
            print("You can now share the ZIP file with your team.")
        else:
            print("\n✗ FAILED! Check the log file for details.")
        
        # Ask if user wants to package another project
        print("\nPackage another project? (yes/no)")
        response = input("> ").strip().lower()
        if response not in ['yes', 'y']:
            print("Goodbye!")
            return


# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Package Unity projects for sharing by removing unnecessary files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python unity_packager.py
  python unity_packager.py /path/to/unity/project
  python unity_packager.py /path/to/unity/project --output /path/to/output
  python unity_packager.py /path/to/unity/project --verbose
        """
    )
    
    parser.add_argument(
        'project_path',
        nargs='?',
        type=str,
        help='Path to the Unity project folder'
    )
    
    parser.add_argument(
        '-o', '--output',
        type=str,
        help='Output directory for the ZIP file (default: project parent directory)'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose logging'
    )
    
    args = parser.parse_args()
    
    # Set up logging
    global logger
    logger = setup_logging(args.verbose)
    
    try:
        if args.project_path:
            # Command line mode
            project_path = Path(args.project_path).resolve()
            output_dir = Path(args.output).resolve() if args.output else None
            
            success = package_unity_project(project_path, output_dir)
            sys.exit(0 if success else 1)
        else:
            # Interactive mode
            interactive_mode()
            sys.exit(0)
            
    except KeyboardInterrupt:
        logger.info("\nOperation cancelled by user (Ctrl+C)")
        sys.exit(1)
    except Exception as e:
        logger.exception(f"Unexpected error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
